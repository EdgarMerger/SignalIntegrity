\hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar}{}\section{Lev\+Mar Class Reference}
\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar}\index{Lev\+Mar@{Lev\+Mar}}


Implements the Levenberg-\/\+Marquardt algorithm for non-\/linear fitting.  




Inheritance diagram for Lev\+Mar\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=236pt]{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Lev\+Mar\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=236pt]{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a5580a7fcf0bfd317a8f8c7c80eefdd69}{\+\_\+\+\_\+init\+\_\+\+\_\+} (self, callback=None)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
def \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a4657ab652abd49c90e9541299fa5e9d8}{fF} (self, a)
\begin{DoxyCompactList}\small\item\em implements F(a) \end{DoxyCompactList}\item 
def \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a2cb2f2f3d90e9eff6180a5b6a5ffa5cc}{f\+Partial\+F\+Partiala} (self, a, m, Fa=None)
\begin{DoxyCompactList}\small\item\em partial derivative of F(a) with respect to a\mbox{[}m\mbox{]} \end{DoxyCompactList}\item 
def \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a5852efb9aab8530b863efac8008cd425}{fJ} (self, a, Fa=None)
\begin{DoxyCompactList}\small\item\em Calculates the Jacobian matrix. \end{DoxyCompactList}\item 
def \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a9959e9bb037bdf52fad0a1af157ec0ce}{Initialize} (self, a, y, w=None)
\begin{DoxyCompactList}\small\item\em Initializes the fitter for optimizing the values of F(a) such that they equal y in a weighted least-\/squares sense, with w providing the weights. \end{DoxyCompactList}\item 
def \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_ac4e956c4e88489e4e3f11d7fde09d613}{Iterate} (self)
\begin{DoxyCompactList}\small\item\em Performs one iteration. \end{DoxyCompactList}\item 
def \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_acfa2263d4f73bf98053a5a8ed10a4c41}{Solve} (self)
\begin{DoxyCompactList}\small\item\em Solves for a such that F(a) equals y in a weighted least-\/squares sense. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a4e9e41b9d341c6749d784fb67271ccdd}{Adjust\+Variables\+After\+Iteration} (a)
\begin{DoxyCompactList}\small\item\em Adjust\+Variables\+After\+Iteration. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a2a7e7b39bfc7a6094ba7f3173dc4e571}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a2a7e7b39bfc7a6094ba7f3173dc4e571}} 
\hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a2a7e7b39bfc7a6094ba7f3173dc4e571}{m\+\_\+lambda}
\begin{DoxyCompactList}\small\item\em starting value for lambda \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a71c5d282ccf15f6d7b85d3ee4d5191bb}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a71c5d282ccf15f6d7b85d3ee4d5191bb}} 
\hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a71c5d282ccf15f6d7b85d3ee4d5191bb}{m\+\_\+lambdamin}
\begin{DoxyCompactList}\small\item\em minimum value of lambda \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a255cd226c6b1ca682c451ff25d530990}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a255cd226c6b1ca682c451ff25d530990}} 
\hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a255cd226c6b1ca682c451ff25d530990}{m\+\_\+lambdamax}
\begin{DoxyCompactList}\small\item\em maximum value of lambda \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a6f9afbdcacf8ccb23b7bf8ff291d4abb}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a6f9afbdcacf8ccb23b7bf8ff291d4abb}} 
\hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a6f9afbdcacf8ccb23b7bf8ff291d4abb}{m\+\_\+lambda\+Multiplier}
\begin{DoxyCompactList}\small\item\em amount to multiply by lambda on successful iterations (and amount to divide lambda by on unsuccessful ones) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a8b2c1114ff1557c8d2b3723a6c7b1c18}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a8b2c1114ff1557c8d2b3723a6c7b1c18}} 
\hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a8b2c1114ff1557c8d2b3723a6c7b1c18}{m\+\_\+epsilon}
\begin{DoxyCompactList}\small\item\em delta used for numerical derivative calculation \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Implements the Levenberg-\/\+Marquardt algorithm for non-\/linear fitting. 

To use this class, you derive your class for fitting some arbitrary function to some data from Le\+Vmar. The function must contain, at a minimum, an {\bfseries init} function for construction and a function f\+F(self,a), which implements the function y=f(a) where ideally a is a vector of numbers and y is a vector of numbers in matrix form. In other words, if you are fitting a 3 variable function f(a0,a1,a2)=y -\/ you are trying to find the best values of a0, a1, and a2 that cause f(a0,a1,a2) to be the closes to y in a least-\/squares sense, then your a would be something like \mbox{[}\mbox{[}a0\mbox{]},\mbox{[}a1\mbox{]},\mbox{[}a2\mbox{]}\mbox{]} and your y would look similar. In this way, a is a 3x1 element matrix.

During the fit, \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar}{Lev\+Mar} will call the function fJ, which in turn calls f\+Partial\+F\+Partiala with a and m being the index of the variable in a to take the derivative with respect to. If your derived class does not overload fJ and/or f\+Partial\+F\+Partiala, \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar}{Lev\+Mar} will compute a numerical derivative using the value self.\+m\+\_\+epsilon as the delta. If you have analytic derivatives and don\textquotesingle{}t want derivatives calculated numerically, you overload fJ and return a matrix that is R a M where R is the number of elements in y and M is the number of elements in a where each J\mbox{[}r\mbox{]}\mbox{[}m\mbox{]} is the partial derivative of F with respect a\mbox{[}m\mbox{]} at element r of the output. 

Definition at line 49 of file Lev\+Mar.\+py.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a5580a7fcf0bfd317a8f8c7c80eefdd69}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a5580a7fcf0bfd317a8f8c7c80eefdd69}} 
\index{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}!\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}!Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+init\+\_\+\+\_\+()}{\_\_init\_\_()}}
{\footnotesize\ttfamily def \+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{callback = {\ttfamily None} }\end{DoxyParamCaption})}



Constructor. 


\begin{DoxyParams}{Parameters}
{\em callback} & a callback function to call during calculation \\
\hline
\end{DoxyParams}


Definition at line 54 of file Lev\+Mar.\+py.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a4e9e41b9d341c6749d784fb67271ccdd}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a4e9e41b9d341c6749d784fb67271ccdd}} 
\index{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}!Adjust\+Variables\+After\+Iteration@{Adjust\+Variables\+After\+Iteration}}
\index{Adjust\+Variables\+After\+Iteration@{Adjust\+Variables\+After\+Iteration}!Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}}
\subsubsection{\texorpdfstring{Adjust\+Variables\+After\+Iteration()}{AdjustVariablesAfterIteration()}}
{\footnotesize\ttfamily def Adjust\+Variables\+After\+Iteration (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Adjust\+Variables\+After\+Iteration. 


\begin{DoxyParams}{Parameters}
{\em a} & list of lists matrix a a contains the new variables produced as a result of an iteration\\
\hline
\end{DoxyParams}
if not overridden, nothing happens, but if this function is overridden in the derived class, it provides an opportunity to make adjustments to the variables. Examples are things like making variables real when during iteration they could become complex or making variables positive. The good thing about this function is that these adjustments are made prior to making decisions on the success of the iteration meaning that sometime the a resulting from an iteration reduces mean-\/squared error between F(a) and y, but the a values are invalid and only valid after adjustment. If, after the adjustment, the mean-\/squared error is not reduced, the iteration fails. 

Definition at line 122 of file Lev\+Mar.\+py.

\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a4657ab652abd49c90e9541299fa5e9d8}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a4657ab652abd49c90e9541299fa5e9d8}} 
\index{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}!fF@{fF}}
\index{fF@{fF}!Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}}
\subsubsection{\texorpdfstring{f\+F()}{fF()}}
{\footnotesize\ttfamily def fF (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{a }\end{DoxyParamCaption})}



implements F(a) 


\begin{DoxyParams}{Parameters}
{\em a} & list of lists representing matrix a \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
F(a) in the overloaded function if the function is not overloaded in the derived class, raises an exception 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em raise} & if not overloaded. \\
\hline
\end{DoxyExceptions}


Definition at line 69 of file Lev\+Mar.\+py.

\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a5852efb9aab8530b863efac8008cd425}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a5852efb9aab8530b863efac8008cd425}} 
\index{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}!fJ@{fJ}}
\index{fJ@{fJ}!Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}}
\subsubsection{\texorpdfstring{f\+J()}{fJ()}}
{\footnotesize\ttfamily def fJ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{a,  }\item[{}]{Fa = {\ttfamily None} }\end{DoxyParamCaption})}



Calculates the Jacobian matrix. 


\begin{DoxyParams}{Parameters}
{\em a} & list of lists matrix a \\
\hline
{\em Fa} & optional previously calculated F(a) to avoid double calculation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Jacobian matrix The Jacobian matrix is R x M where R is the number of elements in F(a) and M is the number of elements in a where each J\mbox{[}r\mbox{]}\mbox{[}m\mbox{]} is the partial derivative of F with respect a\mbox{[}m\mbox{]} at element r of the output.
\end{DoxyReturn}
This function can be overloaded in the derived class if analytic partial derivatives are known, otherwise numerical partial derivatives are calculated using \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a2cb2f2f3d90e9eff6180a5b6a5ffa5cc}{f\+Partial\+F\+Partiala()} 

Definition at line 97 of file Lev\+Mar.\+py.

\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a2cb2f2f3d90e9eff6180a5b6a5ffa5cc}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a2cb2f2f3d90e9eff6180a5b6a5ffa5cc}} 
\index{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}!f\+Partial\+F\+Partiala@{f\+Partial\+F\+Partiala}}
\index{f\+Partial\+F\+Partiala@{f\+Partial\+F\+Partiala}!Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}}
\subsubsection{\texorpdfstring{f\+Partial\+F\+Partiala()}{fPartialFPartiala()}}
{\footnotesize\ttfamily def f\+Partial\+F\+Partiala (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{a,  }\item[{}]{m,  }\item[{}]{Fa = {\ttfamily None} }\end{DoxyParamCaption})}



partial derivative of F(a) with respect to a\mbox{[}m\mbox{]} 


\begin{DoxyParams}{Parameters}
{\em a} & list of lists matrix a \\
\hline
{\em m} & index of element in a which to take partial derivative with respect to \\
\hline
{\em Fa} & optional previously calculated F(a) to avoid double calculation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the partial derivative of F(a) with respect to element m in a 
\end{DoxyReturn}


Definition at line 78 of file Lev\+Mar.\+py.

\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a9959e9bb037bdf52fad0a1af157ec0ce}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_a9959e9bb037bdf52fad0a1af157ec0ce}} 
\index{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}!Initialize@{Initialize}}
\index{Initialize@{Initialize}!Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}}
\subsubsection{\texorpdfstring{Initialize()}{Initialize()}}
{\footnotesize\ttfamily def Initialize (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{a,  }\item[{}]{y,  }\item[{}]{w = {\ttfamily None} }\end{DoxyParamCaption})}



Initializes the fitter for optimizing the values of F(a) such that they equal y in a weighted least-\/squares sense, with w providing the weights. 


\begin{DoxyParams}{Parameters}
{\em a} & list of lists matrix a \\
\hline
{\em y} & list of lists matrix y \\
\hline
{\em w} & (optional) list of lists weights matrix w \\
\hline
\end{DoxyParams}


Definition at line 131 of file Lev\+Mar.\+py.

\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_ac4e956c4e88489e4e3f11d7fde09d613}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_ac4e956c4e88489e4e3f11d7fde09d613}} 
\index{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}!Iterate@{Iterate}}
\index{Iterate@{Iterate}!Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}}
\subsubsection{\texorpdfstring{Iterate()}{Iterate()}}
{\footnotesize\ttfamily def Iterate (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}



Performs one iteration. 

Usually, this function should not be used. It can be used to take each iteration manually.

Usually \hyperlink{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_acfa2263d4f73bf98053a5a8ed10a4c41}{Solve()} is used, which takes these iterations, but tests convergence and decides when the iterating should end. 

Definition at line 161 of file Lev\+Mar.\+py.

\mbox{\Hypertarget{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_acfa2263d4f73bf98053a5a8ed10a4c41}\label{classSignalIntegrity_1_1Fit_1_1LevMar_1_1LevMar_acfa2263d4f73bf98053a5a8ed10a4c41}} 
\index{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}!Solve@{Solve}}
\index{Solve@{Solve}!Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar@{Signal\+Integrity\+::\+Fit\+::\+Lev\+Mar\+::\+Lev\+Mar}}
\subsubsection{\texorpdfstring{Solve()}{Solve()}}
{\footnotesize\ttfamily def Solve (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}



Solves for a such that F(a) equals y in a weighted least-\/squares sense. 



Definition at line 205 of file Lev\+Mar.\+py.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Py\+S\+I/\+Signal\+Integrity/\+Fit/Lev\+Mar.\+py\end{DoxyCompactItemize}
